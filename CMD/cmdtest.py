import cmd, os, time

def banner():

    return """
     _                                 
    | |                                
    | |__   __ _ _ __  _ __   ___ _ __ 
    | '_ \ / _` | '_ \| '_ \ / _ \ '__|
    | |_) | (_| | | | | | | |  __/ |   
    |_.__/ \__,_|_| |_|_| |_|\___|_|   
    
    """

def setup_environment():
    global working_dir
    working_dir = os.path.expanduser("~") + '/.cmdtest/'
    if not os.path.isdir(working_dir):
        os.makedirs(working_dir)


def load_history():
    file_path = working_dir + '.command_history'
    _hst = []
    if os.path.exists(file_path):
        file = open(file_path,'r')
        for line in file.readlines():
            _hst += [line.strip()]

    return _hst

class launchCMD(cmd.Cmd):

    def __init__(self):
        cmd.Cmd.__init__(self)
        self.prompt = "$>"
        self.intro = banner()
        self.commands = ['greet', 'exit', 'history', 'shell', 'help']
        #self.complete = None

    def preloop(self):
        """Initialization before prompting user for commands.
           Despite the claims in the Cmd documentaion, Cmd.preloop() is not a stub.
        """
        cmd.Cmd.preloop(self)  ## sets up command completion
        self.history =  load_history() ## Load history if any
        self._locals = {}  ## Initialize execution namespace for user
        self._globals = {}

    """ This method is called after the line has been input but before
        it has been interpreted. If you want to modifdy the input line
        before execution (for example, variable substitution) do it here.
    """
    def precmd(self, line):
        self.history += ['[' + time.strftime("%d/%m/%Y %H:%M:%S") + '] ' + line.strip()]
        return line

    """
    ############################
        STARTING SHELL OP
    ############################  
    """

    def do_shell(self, args):
        """Pass command to a system shell when line begins with '!'"""
        os.system(args)

    def do_greet(self, args):
        """LELELELE"""
        print "[*] Hello, friend"

    def do_history(self, args):
        """Displays commands history"""
        for command in self.history:
            print command

    def completedefault(self, text, line, begidx, endidx):
        command = line.split(' ', 1)[0]

        # generates a list of commands...
        # from all methods in this class that start with 'do_'

        # auto-complete the command
        command = [i for i in self.commands if i.startswith(command)]

        # can not complete a partial arg if...
        # the command can not be found/completed
        if len(command) != 1:
            return [text]

        # calls do_{command} method to load self.params
        getattr(self, 'do_' + command[0])(None)
        return self.params.parse(line, do=False)

    def do_exit(self,args):
        """"Leaves program and store command history"""
        _hst = open(working_dir + '.command_history','a')
        for command in self.history:
            _hst.write(command + '\n')
        _hst.close()
        print "[*] See you :)"
        exit(0)

if __name__ == '__main__':
    setup_environment()
    _cmd = launchCMD()
    _cmd.cmdloop()
